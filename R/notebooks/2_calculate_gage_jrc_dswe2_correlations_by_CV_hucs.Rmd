---
title: "Calculate correlations between stream gage data and JRC/DSWE 2.0 data in California's Central Valley"
fontsize: 9
output: html_notebook
editor_options:
  chunk_output_type: inline
---


```{r, echo=FALSE, warning=FALSE, message=FALSE}

## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## 2_calculate_gage_jrc_dswe2_correlations_by_CV_hucs.Rmd
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ---------------------------------------------------------------------- #
#### General setup ####
# ---------------------------------------------------------------------- #

# Load packages in a way that's easy for others to as well
loadPackages <- function(pkgs){
  for (pkg in pkgs){
    #  require returns TRUE invisibly if it was able to load package
    if(!require(pkg, character.only = TRUE)){
      #  If package was not able to load, re-install
      install.packages(pkg, dependencies = TRUE)
      #  Load package after installing
      require(pkg, character.only = TRUE)
    }
  }
}

# Load packages
loadPackages(c("dataRetrieval", "plyr", "tidyverse", 'data.table', 'knitr', 'kableExtra', 'devtools', 'googledrive', 'zoo'))

# Set default as echo FALSE
knitr::opts_chunk$set(echo = FALSE)


```


```{r, echo=FALSE}

# ---------------------------------------------------------------------- #
#### Set NoData threshold ####
# ---------------------------------------------------------------------- #

# This is not dynamic; this identifies which file to load

nodata_threshold <- 5


```


```{r,include = F, results = 'hide'}

# ---------------------------------------------------------------------- #
#### Set files and folders ####
# ---------------------------------------------------------------------- #

cor_type <- 'spearman' #pearson' #'kendall' 

path.data <-  "E:/projects/place/data"

file.in <- file.path(path.data, paste0("CV_dswe_jrc_gage_", nodata_threshold, "pct_nodata_merged.RData"))

# Out file specifies correlation test
file.out <- paste0("CV_dswe_jrc_gage_", nodata_threshold, 'pct_nodata_correlations_', cor_type, ".RData")

```


```{r, echo=FALSE}

# ---------------------------------------------------------------------- #
#### Load file of processed data ####
# ---------------------------------------------------------------------- #

load(file.in)

```


```{r, echo=FALSE, warning=FALSE, include=FALSE}

# ---------------------------------------------------------------------- #
# Calculate correlations between imagery and gages for all HUCs####
# ---------------------------------------------------------------------- #

# Calculate correlations based on reduced data set (i.e., NA water values are not yet interpolated)
# n is the number of months on which the correlation is based

# original
pk_ds_sg.cor.all <- pk_ds_sg %>%
  group_by(huc8.img, site_no, type) %>%
  mutate(cor = cor(water, mean_va, use = "pairwise.complete.obs", method = cor_type),
            n = sum(!is.na(water)))

# cor.test gives the p value as well
# pk_ds_sg.cor.all <- pk_ds_sg %>% 
#   group_by(huc8.img, site_no, type) %>% 
#   filter_at(vars(water), all_vars(sum(!is.na(.)) > 4)) %>% # may not be necessary; removes when # of NA water > 4
#   mutate(p = cor.test(water, mean_va, method = cor_type)$p.value,
#          cor = cor.test(water, mean_va, method = cor_type)$estimate,
#          n = sum(!is.na(water))) 

rm(pk_ds_sg)

```



```{r, echo=FALSE, warning=FALSE, include=FALSE}

# ---------------------------------------------------------------------- #
# Restrict correlation file ####
# ---------------------------------------------------------------------- #

# Convert factor to number - otherwise factors trip up operation

pk_ds_sg.cor.all <- pk_ds_sg.cor.all %>%
      ungroup() %>% 
      mutate(huc8.img = as.numeric(as.character(huc8.img)),
             huc8.sg = as.numeric(as.character(huc8.sg)))

# ALL correlations for rows where imagery HUC = stream gage HUC
pk_ds_sg.cor.1 <- pk_ds_sg.cor.all %>% 
   filter(huc8.img == huc8.sg)

# ALL correlations for rows where imagery HUC != gage HUC. Filter these bc otherwise the file explodes in size
pk_ds_sg.cor.2 <- pk_ds_sg.cor.all %>%
  filter(huc8.img != huc8.sg) %>% 
  filter(cor > 0.5)

# ONLY max correlation of imagery with an external streamgage
#### Ideally we would have the max correlations for both gages (DSWE and JRC) if they're not the same; that is,
#### if the max corr for the JRC dataset in a given HUC is with gage X, we would also have the values for the 
#### correlation of DSWE data with that gage. Currently, the final set only has the max correlation for
#### each dataset, meaning the gages can be different. Edit: changed such that all correlations are in the external
#### gage dataset, so long as the correlations are > 0.3

# pk_ds_sg.cor.2.max <- pk_ds_sg.cor.2 %>% 
#  filter(cor == max(cor)) 

# Combine - all correlations for imagery HUC = sg HUC, all corr for imagery HUC != sg HUC where cor > 0.3
 pk_ds_sg.cor <- bind_rows(pk_ds_sg.cor.1, pk_ds_sg.cor.2) #.max)

 rm(pk_ds_sg.cor.1, pk_ds_sg.cor.2, pk_ds_sg.cor.all)
```


```{r, echo=FALSE, message=FALSE, include=FALSE}

# ---------------------------------------------------------------------- #
#### Function: Get coefficients for each correlation for 1st order LR ####
# ---------------------------------------------------------------------- #

# Function to apply linear fit
lm_fit <- function(f) {
 # print(head(f))
  fit <- lm(water ~ mean_va, data = f)
  results <- broom::tidy(fit)
  f$b <- results$estimate[1]
  f$m <- results$estimate[2]
#  if (residuals(fit)[1][[1]] > 0 & nrow(f) > 3) {  # necessary to put this in to screen overfit lm's...sometimes
    #   }
  return(f)
}

```


```{r, echo=FALSE, message=FALSE, include=FALSE}

# ---------------------------------------------------------------------- #
#### Function: Get coefficients for each correlation for 2nd order LR ####
# ---------------------------------------------------------------------- #

# Function to apply linear fit
lm_fit2 <- function(f) { 
  fit <- lm(water ~ mean_va + I(mean_va^2), data = f)
  results <- broom::tidy(fit)
  f$b <- results$estimate[1]
  f$m <- results$estimate[2]
  f$m2 <- results$estimate[3]
  f$r2 <- summary(fit)$r.squared

  return(f)
}

```



```{r, echo = FALSE, message=FALSE, include=FALSE}
# ------------------------------------------------------------------------------- #
#### Calculate correlation coefficients for imagery and gages from all HUCs - 1st order ####
# ------------------------------------------------------------------------------- #

#ignore hucs in which all imagery values are NA
pk_ds_sg.cor$b <- 0
pk_ds_sg.cor$m <- 0

# Start the clock
start_time <- Sys.time()

pk_ds_sg.int <- pk_ds_sg.cor %>% 
  group_by(huc8.img, site_no, type, parameter_cd, huc8.sg, cor) %>% 
  filter(sum(is.na(water)) != length(water)) %>%
  filter(abs(cor) != 0.0) %>%  
  do(lm_fit(.))

end_time <- Sys.time()
end_time - start_time
  
```



```{r, echo = FALSE, message=FALSE, include=FALSE}
# ------------------------------------------------------------------------------- #
#### Calculate correlation coefficients for imagery and gages from all HUCs - 2nd order####
# ------------------------------------------------------------------------------- #

# Start the clock
start_time <- Sys.time()

pk_ds_sg.int2 <- pk_ds_sg.cor %>% 
  group_by(huc8.img, site_no, type, parameter_cd, huc8.sg, cor) %>% 
  filter(sum(is.na(water)) != length(water)) %>%
  filter(abs(cor) != 0.0) %>%  
  do(lm_fit2(.))

end_time <- Sys.time()
end_time - start_time
  
```


```{r, echo = F, warning = FALSE}

# ---------------------------------------------------------------------- #
#### Get JRC/DSWE correlations ####
# ---------------------------------------------------------------------- #

### Hardwired to use Pearson correlation

# JRC (Pekel data)
pk.sub <- pk[, c('date', 'water', 'huc8')]
colnames(pk.sub)[2] <- 'water_pk'

# DS (DSWE data)
ds.sub <- ds[, c('date', 'water', 'huc8')]
colnames(ds.sub)[2] <- 'water_ds'

# Merge the two!
pk_ds.sub <- merge(pk.sub, ds.sub, by = c('date', 'huc8'))

#### Uncomment to run cor.test and get the p value as well
pk_ds.cor <- pk_ds.sub %>%
  group_by(huc8) %>%
  rename(huc8.img = huc8) %>%
  summarize(cor = cor.test(water_pk, water_ds, method = "pearson")$estimate,
            p = cor.test(water_pk, water_ds, method = "pearson")$p.value,
            n_pekel = sum(!is.na(water_pk)),
            n_dswe = sum(!is.na(water_ds))) # Used to look at correlation between data density and correlation

# Calculate correlations (original)
pk_ds.cor <- pk_ds.sub %>%
    group_by(huc8) %>%
    rename(huc8.img = huc8) %>%
    summarize(cor = cor(water_pk, water_ds, use = "pairwise.complete.obs", method = "pearson"),
            n_pekel = sum(!is.na(water_pk)),
            n_dswe = sum(!is.na(water_ds))) # Used to look at correlation between data density and correlation

rm(ds, ds.sub, pk.sub, pk_ds_sg.cor)
```



```{r, echo=FALSE}
# ---------------------------------------------------------------------- #
#### Replace NA imagery values with interpolated data ####
# ---------------------------------------------------------------------- #

# 1st order
pk_ds_sg.int$water <- ifelse(is.na(pk_ds_sg.int$water), pk_ds_sg.int$mean_va * pk_ds_sg.int$m + pk_ds_sg.int$b, pk_ds_sg.int$water)
pk_ds_sg.int$water <- ifelse(pk_ds_sg.int$water < 0, 0, pk_ds_sg.int$water)

# 2nd order
pk_ds_sg.int2$water <- ifelse(is.na(pk_ds_sg.int2$water), pk_ds_sg.int2$b + pk_ds_sg.int2$mean_va * pk_ds_sg.int2$m + pk_ds_sg.int2$mean_va^2 * pk_ds_sg.int2$m2, pk_ds_sg.int2$water)

```


```{r, echo = FALSE, warning = FALSE}

# ---------------------------------------------------------------------- #
#### Get max correlations within HUC and without ####
# ---------------------------------------------------------------------- #

# Calculate max gage:imagery correlation for each HUC given gages in the same HUC
cor.huc.max <- pk_ds_sg.int %>% 
  filter(huc8.img == huc8.sg) %>% 
  group_by(huc8.img, type) %>% 
  select(-starts_with('water'), -c(date, interp, mean_va, b, m)) %>% 
  slice(which.max(cor)) 

cor.huc.max %>%
  select(c(site_no, huc8.img, huc8.sg, type, cor, n)) %>% 
  arrange(huc8.img) %>% 
  kable(col.names = c("Gage",  "Imagery HUC", "Gage HUC", "Dataset", "cor", "n"), digits = 3) %>%  
  kable_styling("striped", full_width = FALSE, position = 'left') %>% 
  scroll_box(height = '400px', width = '450px')

# Calculate max gage:imagery correlation for each HUC given all possible gages
cor.all.max <- pk_ds_sg.int %>% 
  group_by(huc8.img, type) %>% 
  slice(which.max(cor)) %>% 
  group_by(site_no) %>% 
  select(-starts_with('water'), -c(date, interp, mean_va, b, m)) %>% 
  mutate(n_site = n_distinct(huc8.img)) %>%  # Get the number of times each gage appears
  ungroup()

# Are the gage and imagery in the same HC?
cor.all.max$same_huc <- NA
cor.all.max$same_huc <- 'Y'
cor.all.max$same_huc[cor.all.max$huc8.img != cor.all.max$huc8.sg] <- 'N'

```

```{r, echo = FALSE, warning = FALSE}

# ---------------------------------------------------------------------- #
#### Get max correlations external to HUCs ####
# ---------------------------------------------------------------------- #

# Calculate max gage:imagery correlation for each HUC given all possible gages
cor.all.max <- pk_ds_sg.int %>% 
  group_by(huc8.img, type) %>% 
  slice(which.max(cor)) %>% 
  group_by(site_no) %>% 
  select(-starts_with('water'), -c(date, interp, mean_va, b, m)) %>% 
  mutate(n_site = n_distinct(huc8.img)) %>%  # Get the number of times each gage appears
  ungroup()

# Are the gage and imagery in the same HC?
cor.all.max$same_huc <- NA
cor.all.max$same_huc <- 'Y'
cor.all.max$same_huc[cor.all.max$huc8.img != cor.all.max$huc8.sg] <- 'N'


cor.all.max %>%
  select(c(site_no, huc8.img, huc8.sg, type, cor, n)) %>% 
  arrange(huc8.img) %>% 
  kable(col.names = c("Gage",  "Imagery HUC", "Gage HUC", "Dataset", "cor", "n"), digits = 3) %>%  
  kable_styling("striped", full_width = FALSE, position = 'left') %>% 
  scroll_box(height = '400px', width = '450px')

```



```{r, echo = FALSE, error = FALSE}

# ---------------------------------------------------------------------- #
#### Calculate correlations between gages and all DSWE classes ####
# ---------------------------------------------------------------------- #

# Select only uninterpolated DSWE values and within-HUC comparisons
ds_sg <- pk_ds_sg.int %>% 
    ungroup() %>% 
    filter(huc8.img == huc8.sg & type == 'dswe' & interp == 'N')

# rowSumming NA and 0 returns NA rather than 0. Setting it up like this returns 0 instead of NA.
# Sum water plus class 2,3,4
ds_sg$waterplus2 <- rowSums(ds_sg[, c('water', 'water2')], na.rm = TRUE) * 
        ifelse(rowSums(is.na(ds_sg[, c('water', 'water2')])) == ncol(ds_sg[, c('water', 'water2')]), NA, 1) 

ds_sg$waterplus23 <- rowSums(ds_sg[, c('water', 'water2', 'water3')], na.rm = TRUE) * 
        ifelse(rowSums(is.na(ds_sg[, c('water', 'water2', 'water3')])) == ncol(ds_sg[, c('water', 'water2', 'water3')]), NA, 1) 

ds_sg$waterplus24 <- rowSums(ds_sg[, c('water', 'water2', 'water3', 'water4')], na.rm = TRUE) * 
        ifelse(rowSums(is.na(ds_sg[, c('water', 'water2', 'water3', 'water4')])) == ncol(ds_sg[, c('water', 'water2', 'water3', 'water4')]), NA, 1) 

# Calculate correlations
ds_sg.cor <- ds_sg %>% 
  filter(!is.na(mean_va)) %>% 
  group_by(huc8.img, site_no, huc8.sg, parameter_cd) %>% 
  summarize(cor1 = cor(water, mean_va, use = "complete.obs", method = cor_type),
                   cor2 = cor(water2, mean_va,use = "complete.obs", method = cor_type),
                   cor12 = cor(waterplus2, mean_va,use = "complete.obs", method = cor_type),
                   cor123 = cor(waterplus23, mean_va,use = "complete.obs", method = cor_type),
                   cor1234 = cor(waterplus24, mean_va,use = "complete.obs", method = cor_type),
            n = sum(!is.na(water))) 

```



```{r, echo = FALSE}

# ---------------------------------------------------------------------- #
# save file of merged data ####
# ---------------------------------------------------------------------- #

save(cor.all.max, cor.huc.max, pk_ds.cor, ds_sg.cor, pk_ds, pk_ds_sg.int, pk_ds_sg.int2, file = file.path(path.data, file.out))
# 

```

